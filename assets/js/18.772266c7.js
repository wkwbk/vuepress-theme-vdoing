(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{434:function(v,_,a){"use strict";a.r(_);var t=a(7),e=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("Java 第一阶段")]),v._v(" "),_("hr"),v._v(" "),_("h2",{attrs:{id:"变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[v._v("#")]),v._v(" 变量")]),v._v(" "),_("p",[v._v("变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量的值。")]),v._v(" "),_("ul",[_("li",[v._v("不同的变量，类型不同，占用的空间大小不同。")]),v._v(" "),_("li",[v._v("变量必须先声明，后使用。")]),v._v(" "),_("li",[v._v("变量在同一个作用域内不能重名。")])]),v._v(" "),_("h3",{attrs:{id:"基本数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型"}},[v._v("#")]),v._v(" 基本数据类型")]),v._v(" "),_("p",[v._v("每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://img.lisir.me/image/posts/1d11e0f7/20240427085447.png",alt:"20240427085447"}})]),v._v(" "),_("h4",{attrs:{id:"整数类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#整数类型"}},[v._v("#")]),v._v(" 整数类型")]),v._v(" "),_("ul",[_("li",[v._v("整数类型有固定的范围和字段长度，不受操作系统的影响。")]),v._v(" "),_("li",[v._v("整数常量默认为 int 型，声明 long 型常量需要在后面加 "),_("code",[v._v("l")]),v._v(" 或 "),_("code",[v._v("L")]),v._v("。")]),v._v(" "),_("li",[v._v("bit（位）是计算机最小存储单位，byte（字节）是计算机中基本存储单位，1byte 等于 8bit。")])]),v._v(" "),_("h4",{attrs:{id:"浮点类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浮点类型"}},[v._v("#")]),v._v(" 浮点类型")]),v._v(" "),_("ul",[_("li",[v._v("浮点数 = 符号位 + 指数位 + 尾数位")]),v._v(" "),_("li",[v._v("尾数部分可能丢失，造成精度损失（小数都是近似值）。")]),v._v(" "),_("li",[v._v("浮点数常量默认为 double 型，声明 float 型常量需要在后面加 "),_("code",[v._v("f")]),v._v(" 或 "),_("code",[v._v("F")]),v._v("。")])]),v._v(" "),_("h4",{attrs:{id:"字符类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符类型"}},[v._v("#")]),v._v(" 字符类型")]),v._v(" "),_("ul",[_("li",[v._v("字符常量是用单引号括起来的单个字符。")]),v._v(" "),_("li",[v._v("转义字符 "),_("code",[v._v("\\")]),v._v(" 可以将其后的字符转变为特殊字符常量。")]),v._v(" "),_("li",[v._v("char 本质是一个整数，在输出时，是 Unicode 码对应的字符。")]),v._v(" "),_("li",[v._v("可以直接给 char 赋一个整数，然后输出时，会按照对应的 Unicode 字符输出。")]),v._v(" "),_("li",[v._v("char 是可以进行运算的，相当于一个整数。")])]),v._v(" "),_("h4",{attrs:{id:"布尔类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#布尔类型"}},[v._v("#")]),v._v(" 布尔类型")]),v._v(" "),_("ul",[_("li",[v._v("布尔类型数据只允许取值 "),_("code",[v._v("true")]),v._v(" 和 "),_("code",[v._v("false")]),v._v("，没有 "),_("code",[v._v("null")]),v._v("。")])]),v._v(" "),_("h3",{attrs:{id:"基本数据类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型转换"}},[v._v("#")]),v._v(" 基本数据类型转换")]),v._v(" "),_("p",[v._v("精度就是这个类型在内存中分配的内存空间，也就是容量。")]),v._v(" "),_("h4",{attrs:{id:"自动类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自动类型转换"}},[v._v("#")]),v._v(" 自动类型转换")]),v._v(" "),_("p",[v._v("在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型。")]),v._v(" "),_("ul",[_("li",[v._v("char ---\x3e int ---\x3e long ---\x3e float ---\x3e double")]),v._v(" "),_("li",[v._v("byte ---\x3e short ---\x3e int ---\x3e long ---\x3e float ---\x3e double")])]),v._v(" "),_("p",[v._v("注意细节：")]),v._v(" "),_("ul",[_("li",[v._v("多种类型的数据混合运算时，系统首先自动将所有的数据转换成精度最大的那种数据类型，然后再进行计算。")]),v._v(" "),_("li",[v._v("把精度大的数据类型赋值给精度小的数据类型时，就会报错，反之就会进行自动类型转换。")]),v._v(" "),_("li",[v._v("在进行赋值时，byte 或 short 与 char 之间不会相互自动转换。")]),v._v(" "),_("li",[v._v("byte、short、char 它们三者可以进行混合运算，在运算时首先转换为 int 类型。")]),v._v(" "),_("li",[v._v("boolean 不参与转换。")]),v._v(" "),_("li",[v._v("表达式结果的类型自动提升为操作数中精度最大的类型。")])]),v._v(" "),_("h4",{attrs:{id:"强制类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强制类型转换"}},[v._v("#")]),v._v(" 强制类型转换")]),v._v(" "),_("p",[v._v("自动类型转换的逆过程，将精度大的数据类型转换为精度小的数据类型。\n使用时要加上强制转换符 "),_("code",[v._v("()")]),v._v("，但可能造成精度降低或溢出，格外要注意。")]),v._v(" "),_("p",[v._v("注意细节：")]),v._v(" "),_("ul",[_("li",[v._v("强转符号只针对最近的操作数有效，多个操作数往往会使用小括号提升优先级。")]),v._v(" "),_("li",[v._v("char 可以保存 int 的常量值，但不能保存 int 的变量值，需要强转。")]),v._v(" "),_("li",[v._v("byte、short、char 在进行运算时，当做 int 处理。")])]),v._v(" "),_("h4",{attrs:{id:"转-string-类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#转-string-类型"}},[v._v("#")]),v._v(" 转 String 类型")]),v._v(" "),_("ul",[_("li",[v._v("基本数据类型转 String 类型：将基本数据类型的值 + "),_("code",[v._v('""')]),v._v(" 即可。")]),v._v(" "),_("li",[v._v("String 类型转基本数据类型：通过基本数据类型的包装类调用 parseXxx 方法即可。")])]),v._v(" "),_("h2",{attrs:{id:"运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运算符"}},[v._v("#")]),v._v(" 运算符")]),v._v(" "),_("p",[v._v("运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。")]),v._v(" "),_("h3",{attrs:{id:"算数运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算数运算符"}},[v._v("#")]),v._v(" 算数运算符")]),v._v(" "),_("p",[v._v("算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://img.lisir.me/image/posts/1d11e0f7/20240427131216.png",alt:"20240427131216"}})]),v._v(" "),_("p",[v._v("注意细节：")]),v._v(" "),_("blockquote",[_("ul",[_("li",[v._v("对于除号 "),_("code",[v._v("/")]),v._v("，它的整数除和小数除是有区别的，整数之间做除法时，只保留整数部分舍弃小数部分。")]),v._v(" "),_("li",[v._v("取模 "),_("code",[v._v("%")]),v._v(" 的本质，"),_("code",[v._v("a % b")]),v._v(" 等于 "),_("code",[v._v("a - (int)(a / b) * b")]),v._v("。")])])]),v._v(" "),_("p",[_("code",[v._v("+")]),v._v(" 号的使用：")]),v._v(" "),_("blockquote",[_("ul",[_("li",[v._v("当左右两边都是数值型时，则做加法运算。")]),v._v(" "),_("li",[v._v("当左右两边有一方为字符串时，则做拼接运算。")]),v._v(" "),_("li",[v._v("运算顺序是从左到右。")])])]),v._v(" "),_("h3",{attrs:{id:"关系运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关系运算符"}},[v._v("#")]),v._v(" 关系运算符")]),v._v(" "),_("p",[v._v("关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false。\n关系表达式经常用在 if 结构的条件中或循环结构的条件中。\n关系运算符组成的表达式，我们称为关系表达式。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://img.lisir.me/image/posts/1d11e0f7/20240430091938.png",alt:"20240430091938"}})]),v._v(" "),_("h3",{attrs:{id:"逻辑运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#逻辑运算符"}},[v._v("#")]),v._v(" 逻辑运算符")]),v._v(" "),_("p",[v._v("用于连接多个条件表达式，最终的结果也是一个 boolean 值。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://img.lisir.me/image/posts/1d11e0f7/20240430092401.png",alt:"20240430092401"}})]),v._v(" "),_("p",[v._v("运算规则：")]),v._v(" "),_("blockquote",[_("ul",[_("li",[_("code",[v._v("a & b")]),v._v(" 逻辑与：当 a 和 b 同时为 true，则结果为 true，否则为 false。")]),v._v(" "),_("li",[_("code",[v._v("a && b")]),v._v(" 短路与：当 a 和 b 同时为 true，则结果为 true，否则为 false。")]),v._v(" "),_("li",[_("code",[v._v("a | b")]),v._v(" 逻辑或：当 a 和 b 有一个为 true，则结果为 true，否则为 false。")]),v._v(" "),_("li",[_("code",[v._v("a || b")]),v._v(" 短路或：当 a 和 b 有一个为 true，则结果为 true，否则为 false。")]),v._v(" "),_("li",[_("code",[v._v("a ^ b")]),v._v(" 逻辑异或：当 a 和 b 不同时，则结果为 true，否则为 false。")]),v._v(" "),_("li",[_("code",[v._v("!a")]),v._v(" 取反，或者非运算：当 a 为 true，则结果为 false，当 a 为 false 是，结果为 true。")])])]),v._v(" "),_("p",[_("code",[v._v("&&")]),v._v(" 与 "),_("code",[v._v("&")]),v._v(" 的区别：")]),v._v(" "),_("blockquote",[_("ul",[_("li",[_("code",[v._v("&")]),v._v(" 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低。")]),v._v(" "),_("li",[_("code",[v._v("&&")]),v._v(" 短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高。")])])]),v._v(" "),_("p",[_("code",[v._v("||")]),v._v(" 与 "),_("code",[v._v("|")]),v._v(" 的区别：")]),v._v(" "),_("blockquote",[_("ul",[_("li",[_("code",[v._v("|")]),v._v(" 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低。")]),v._v(" "),_("li",[_("code",[v._v("||")]),v._v(" 短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高。")])])]),v._v(" "),_("h3",{attrs:{id:"赋值运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#赋值运算符"}},[v._v("#")]),v._v(" 赋值运算符")]),v._v(" "),_("ul",[_("li",[v._v("基本赋值运算符："),_("code",[v._v("=")])]),v._v(" "),_("li",[v._v("复合赋值运算符："),_("code",[v._v("+=")]),v._v("，"),_("code",[v._v("-=")]),v._v("，"),_("code",[v._v("*=")]),v._v("，"),_("code",[v._v("/=")]),v._v("，"),_("code",[v._v("%=")]),v._v(" 等。")])]),v._v(" "),_("p",[v._v("注意细节：")]),v._v(" "),_("ul",[_("li",[v._v("运算顺序从右往左。")]),v._v(" "),_("li",[v._v("赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值。")])]),v._v(" "),_("h3",{attrs:{id:"三元运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三元运算符"}},[v._v("#")]),v._v(" 三元运算符")]),v._v(" "),_("p",[v._v("条件表达式 ? 表达式一 : 表达式二;")]),v._v(" "),_("p",[v._v("运算规则：")]),v._v(" "),_("ul",[_("li",[v._v("如果条件表达式为 true，运算后的结果是表达式一。")]),v._v(" "),_("li",[v._v("如果条件表达式为 false，运算后的结果是表达式二。")])]),v._v(" "),_("h3",{attrs:{id:"位运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#位运算符"}},[v._v("#")]),v._v(" 位运算符")]),v._v(" "),_("h3",{attrs:{id:"运算符优先级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运算符优先级"}},[v._v("#")]),v._v(" 运算符优先级")]),v._v(" "),_("p",[v._v("运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。\n只有单目运算符、赋值运算符是从右向左运算的。\n如下表，上一行运算符总优先于下一行。")]),v._v(" "),_("h2",{attrs:{id:"控制结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#控制结构"}},[v._v("#")]),v._v(" 控制结构")]),v._v(" "),_("h3",{attrs:{id:"顺序控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#顺序控制"}},[v._v("#")]),v._v(" 顺序控制")]),v._v(" "),_("h3",{attrs:{id:"分支控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分支控制"}},[v._v("#")]),v._v(" 分支控制")]),v._v(" "),_("h4",{attrs:{id:"双分支"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双分支"}},[v._v("#")]),v._v(" 双分支")]),v._v(" "),_("h4",{attrs:{id:"嵌套分支"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#嵌套分支"}},[v._v("#")]),v._v(" 嵌套分支")]),v._v(" "),_("h4",{attrs:{id:"switch-分支"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#switch-分支"}},[v._v("#")]),v._v(" switch 分支")]),v._v(" "),_("h3",{attrs:{id:"循环控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#循环控制"}},[v._v("#")]),v._v(" 循环控制")]),v._v(" "),_("h4",{attrs:{id:"for"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#for"}},[v._v("#")]),v._v(" for")]),v._v(" "),_("h4",{attrs:{id:"while"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#while"}},[v._v("#")]),v._v(" while")]),v._v(" "),_("h4",{attrs:{id:"do-while"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#do-while"}},[v._v("#")]),v._v(" do...while")]),v._v(" "),_("h2",{attrs:{id:"数组的排序和查找"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组的排序和查找"}},[v._v("#")]),v._v(" 数组的排序和查找")]),v._v(" "),_("h2",{attrs:{id:"面向对象编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面向对象编程"}},[v._v("#")]),v._v(" 面向对象编程")])])}),[],!1,null,null,null);_.default=e.exports}}]);